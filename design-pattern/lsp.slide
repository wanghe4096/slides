设计模式中的六大原则

wanghe
coolshine.net
wanghe@luojilab.com

* 里氏代换原则

* 继承的优点
- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 
- 提高代码的重用性； 
- 子类可以形成父类，但又异于父类
- 提高代码的可扩展性，实现父类的方法,很多开源框架都是通过继承父类来完成的
- 提高产品或项目的开放性

* 继承的缺点
- 一定的侵入性。只要继承就必须拥有父类的所有性性和方法
- 降低代码的灵活性。 子类必须拥有父类的性性和方法，让子类自由的世界中多了些约速。这在我们用Go构建系统的时， 采用组合方式更为明显
- 增强了耦合性。 当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构
 
* 引入里氏代换原则
Golang 中是通过使用组合来实现继承，区别于java 中使用extends 字段来实现单一的继承规则，c++则采用多重继承的规则，即和go一样， 一个子类可以继承多个父类。 从整体来看， 利大于弊， 那么怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？ 


* 里氏代换原则的定义
所有引用基类的地方必须能透明的使用其子类的方对象

通俗的讲， 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。 但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 

* 里氏代换对于继承的规范
1. 子类必须完全实现父类的方法
2. 子类可以有自己的特性
3. 覆盖或实现父类的方法时输入参数可以被放大
4. 覆写或实现父类的方法时输出结果可以被缩小


* 子类必须完全实现父类的方法
我们在做系统设计时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏夫换原则。 
作者在2.2节中， 举了一个CS游戏中的例子

* 子类可以有自己的特性
子类当然可以有自己的行为和外观，也不是方法和属性，在Go语言中，似乎只能用过接口组合的方式来实现。 否只能靠类型断言来处理。  但是里氏代换可正着用，而不能反着用。 大子类出现的地方，父类未必就可以胜任。

* 覆盖或实现父类的方法时输入参数可以被放大
方法中的输入参数称为前置条件，这是什么意思呢？大家做过Web Service开发应该知道有一个“契约优先” 也就是先定义WSDL接口，这种设计方法也叫做Design by 
ontract (契约设计) ,与里氏替换原则有着异曲同工之秒。 契约制定了， 也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈。这里还是比较难理解的，

也就是子类代替父类传递到调用者中，子类的方法永远都不会被执行。 这是正确的， 如果你想让子类的方法运行，就必覆写父类的方法。 


* 覆写或实现父类的方法时输出结果可以被缩小 

这是什么意思呢， 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏代换原则就要求S必须小于等于T， 也就是说， 要么S和T是同一个类型，要么S是T的子类，为什么呢？ 分两种情况， 如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 如果是重载， 则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下， 就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的


* 总结
采用里氏代替原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。 在实际项目中， 每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常的完美。 
